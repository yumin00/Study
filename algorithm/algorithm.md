# Algorithm
## Sort Alrgorithm
== 오름차순 내림차순 정렬

### 1. 버블
- 인접한 것들 끼리 비교해서 큰 값을 오른쪽으로 작은 값을 왼쪽으로
- 한 번을 반복을 하면 맨 오른쪽에 제일 큰 값이 남음
- 제일 큰 값을 제외하고 다시 반복
- 시간 : n(n-1)/2 => O(n^2)

### 2. 선택 (자리 선택)
- 가장 작은 값을 찾아서 맨 앞에 놓겠다!
- 첫 번째 값과 두 번째 값을 비교해서 작은 값을 min으로 놓고 idx 잡기
- min 값과 세 번째 값을 비교해서 작은 값은 min으로 놓고 idx 잡기
- 한 번 다 돌고 min 값을 맨 앞에 놓기
- 시간 : n(n-1)/2 => O(n^2)

### 3. 삽입
- 두 번째 idx부터 시작
- -1 idx와 비교해서 크면 오른쪽으로..
- 시간(worst) : 오름차순으로 하고 싶은데, 내림차순으로 되어있는 경우 - n(n-1)/2 => O(n^2)
- 시간(best) : O(n) - 뒤에를 먼저 만들어놓으면 끝까지 돌 필요가 없음 : 이미 한 것은 신경쓰지 말자 / 이미 정렬됐으면 보장하고 break

### 4. 병합
**분할정복 divide and conquer**

하나 하나씩 빼서 다시 하나 하나 넣어서 합치는 것

[분할]
- 균등하게 잘라줌
- 배열의 중간을 기준으로 잡아서 두 가지 그룹으로 나눔
- 두 가지 그룹에서 각각 중간을 기준으로 잡아서 다시 두 가지 그룹으로 나눔
- 그룹이 없어질 때까지 분할하기
- 시간 : logN

[정복]
- 합병을 하면서 정렬
- 시간 : N


- 시간 : O(NlogN)
- 분할해서 저장해놔야하기 때문에 메모리가 충분할 때 사용하는 것이 좋다

### 5. 힙
<우선순위 큐>
- min heap
  - 우선순위가 높으면 오름차순
- max heap
  - 우선수위가 높으면 내림차순

- head를 한 번 빼는 것 : O(1)
- 이진트리에서 숫자 정렬(head 채우기) : O(logN) -> N(노드)만[큼 반복

-> O(NlogN)


### 6. 퀵 == goland sort
- 분할정복의 개수가 달라짐
- 합병 sort : idx를 기준으로 균등하게 절반 자름
- 퀵 : idx가 아닌 value 값으로 진행
- 방법
- 원하는 값을 아무거나 잡고 pivot으로 설정
- pivot을 기준으로 왼쪽은 작은 값, 오른쪽은 큰 값 놓기
- 이 방법을 리스트가 0 or 1이 될 때까지 반복
- 시간 : O(NlongN) : 자르면서 정렬하]()
- 기 때문에 다른 NlogN보다 속도가 빠름
- pivot을 어떻게 잡느냐에 따라서 속도가 확 달라짐
  - 이미 정렬되어 있는 상태에서 제일 작은 값을 pivot으로 잡으면 선택정렬(O(N^2))만큼 시간이 걸림


### 7. 기수
- 일의 자리 수 매핑
  - 8 9 52 32 -> 8 - 8 / 9-9 / 2- 52, 32 -> 결과 : 52 32 8 9
- 10의 자리 수 매핑
  - 0 - 8,9 / 3 - 32 / 5 - 52 -> 결과 : 8 9 32 52
- 개수 : n / redis(자리수) : d
- ==> 시간 : O(n*d)
- 숫자가 너무 많으면 메모리를 많이 먹음
- 0부터 9까지의 배열을 모두 가져가기 때문에 메모리를 진짜 많이 먹음

## Sort Alrgorithm 문제 풀이
- [버블 정렬 문제 풀이](../algorithm/bubble_sort.go)
- [선택 정렬 문제 풀이](../algorithm/selection_sort.go)
- [삽입 정렬 문제 풀이](../algorithm/insertion_sort.go)