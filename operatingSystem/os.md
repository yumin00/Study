# OS

*** 운영체제 == 소프트웨어

- 정해진 리소스, 프로세스를 모아서 할당해주는 것 / 이 시간에 무엇을 얼만큼 해야하는지 주는 것
- 정해진 리소스를 효율적으로 사용할 수 있도록 해줌
- 효율적으로 사용할 수 있는 추상화를 제공
- 방화벽을 사용하게 해줌(= 보안)
- os = 프로세스
- cpu = 뇌 : 연산
- 메모리 = 저장 : 
- 스토리지 = : 파일 저장
- 네트워크 : 서로 통신, port? - 게이트 하나하나 (ex. 놀이공원에서 입장하는 곳)
- 프로세스(프로그램/어플리케이션 단위)라는 것을 사용하게 함으로써 cpu를 사용하게 하고, 메모리를 사용하게 하고, 파일을 사용해서 스토리지에 저장하게 해주고, 포트를 사용해서 네트워크를 사용할 수 있음)
- FIFO : 가장 먼저 켜진 것에 리소스를 다 줌, 다른게 켜지면 거기에 리소스를 다 줌
- LRU : cache 가장 최근에 사용한 것에 리소스를 다 줌
- 우선순위 분배해줌


- os가 없다면? : 그래픽 없이 명령어로 직접 다 사용해야함.
- os가 좋지 않다면? : 속도가 느림, 다양한 웹사이트, 어플을 동시에 사용할 수 없음
- os가 나쁘다면? : 하나밖에 못킨다, 제 기능을 못한다


## COMPUTER의 기원
- 암호 푸는 계산기
- ENIAC : 최초의 컴퓨터
- os의 변화
  - Batch : 하나 시키면 하나만, 그 시점에 하나만 = 계산을 하나만 
  - Multiprogramming : 동시에 (리소스) = 계산을 두개 
  - Timesharing : 한 시간에 여러개 프로그램
  - Graphical UI : GUI
  - Smart Device : 스마트폰 같은거
- 1bit 단위 : 0 혹은 1


## os가 프로그램들에게 CPU같은 하드웨어를 사용하게 하는 방법 (리소스 분배 방법)
### Batch
- idle 상태
  - 기계와 CPU의 시간 차이가 너무 많이 남
  - 기계는 계속 일하는데, CPU는 너무 빨라서 기계가 일하는 동안 비는 시간이 생김
    - 그래서 나온 것이 바로 multiprogramming
    - 비는 시간 동안 다른 일을 할 수 있도록
- 해결 방법 : spooling
  - 자기만의 버퍼를 들고 있기
  - ex) 인쇄할 문서를 프린터의 메모리의 버퍼에 로드
- spool의 문제점
  - 비동기작업은 가능하지만, 동기 작업이 불가능함
  - read()작업이 문제. 다 읽은 후 줘야하기 때문에 읽는 동안은 다른 것을 할 수가 없음.

- job swithing
  - 해결 방안 : automatic job sequencing
    - 사람이 직접 스케줄링
    - cpu가 놀지 않게 여러가지 일을 계속 시키는 것
    - 스케줄링을 담당하는 SW에서 프로그램 실행 
  
  

### Multiprogramming
- 2개 이상의 작업을 동시에 실행
- CPU 활용률 극대화 / CPU가 쉬는 시간이 없음
- 운영체제는 열 개의 작업을 메모리에 동시에 유지
- 창이 동시에 켜져있는 것처럼 보이지만, 사실은 메모리를 엄청 빠르게 왔다갔다 하면서 창에 보여주는 것
- 문제
  - 프로그램마다 시간을 공평하게 줌.